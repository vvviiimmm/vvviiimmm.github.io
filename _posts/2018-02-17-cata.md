# Catamorphisms and F-Algebras

> So I often hear the words “catamorphism” and “recursion schemes”. What is that about?

Catamorphisms (or **cata**) are generalizations of the concept of a fold in functional programming. Given an F-Algebra and a recursive data structure a catamorphism will produce a value by recursively evaluating your data structure.
> What is an F-Algebra? Maybe you can show some code examples first?

The setup is not that straightforward so let’s start simple. Let’s say you have the following data structure to represent an expression:

```haskell
data Expression = Value Int 
    | Add Expression Expression
    | Mult Expression Expression deriving Show
```

```scala
sealed trait Expression

case class Value(v: Int) extends Expression
case class Add(e1: Expression, e2: Expression) extends Expression
case class Mult(l: Expression, e2: Expression) extends Expression
```

And a simple expression can look like this:

<iframe src="https://medium.com/media/6c541d687e710637fd7b9975cf293874" frameborder=0></iframe>

<iframe src="https://medium.com/media/99b0ecb1611013ce80e2958b2b3a9ec7" frameborder=0></iframe>

Having just an expression data structure is useless, of course you’ll need a function to evaluate and get the result:

<iframe src="https://medium.com/media/5240f975b10426ba1ef6c5902c585452" frameborder=0></iframe>

<iframe src="https://medium.com/media/ebe7799ec38ab390edbaadb06f854c6f" frameborder=0></iframe>

This is where catamorphism generalization comes in:

<iframe src="https://medium.com/media/a8bf76dc6e6b26c8c9cc3053d4698a0f" frameborder=0></iframe>

<iframe src="https://medium.com/media/865c21a7bb5dc464103928740d25fb9d" frameborder=0></iframe>
> 🤨, but what’s the point? You just applying an argument to a function?

That’s because it’s notReallyCata. The real cata function is generic and does not depend on any particular data structure or evaluator function. See, creation of a recursive data structure and then folding over it is a common pattern that cata tries to generalize.
> Ok, then how the real cata looks like?

<iframe src="https://medium.com/media/a2b0e44c242257bc34dda2fd6b8a7db5" frameborder=0></iframe>
> 🤯

That’s why we started with notReallyCata. We’ll break down the implementation later until it clicks. But now let’s continue with our Expression example. First, we need to get rid of recursion by introducing a type parameter:

<iframe src="https://medium.com/media/e60dc0765e435a3f5f905b2409733e89" frameborder=0></iframe>

<iframe src="https://medium.com/media/0c601f0b353cdcf5ebd193c8cfe82b1a" frameborder=0></iframe>

All references to Expression are replaced with a type parameter so the data structure is no longer recursive.
> Why is there an F at the end of type constructors?

Glad you asked — that’s a hint that ExpressionF can be a Functor:

<iframe src="https://medium.com/media/c461e644686671063f9e9477d55cfbfb" frameborder=0></iframe>

<iframe src="https://medium.com/media/0299bb71edb03db7d596ac2ac00cdf05" frameborder=0></iframe>

Nothing fancy, just applying some function to the wrapped value preserving stucture.
> Not sure why we need that 🤔

It doesn’t makes sense now but it will a bit later. Now, the way we create our expression haven’t changed (except for constructor names):

<iframe src="https://medium.com/media/dbe500f124056cc4d9a250355736a719" frameborder=0></iframe>

<iframe src="https://medium.com/media/5e6a2b0d824452864ec680ad3ce1b5a9" frameborder=0></iframe>

But the resulting type is different:

<iframe src="https://medium.com/media/af8654791af905d368a090ba0f42bd54" frameborder=0></iframe>

<iframe src="https://medium.com/media/351dfa1dbbe63c6e264143e87b92604c" frameborder=0></iframe>

expr collapses everything into a single Expression while exprF encodes information about the nesting level of our expression tree. Speaking about evaluation, this is how we can go about implementing eval for ExpressionF:

<iframe src="https://medium.com/media/3372a244c0b2b619498b97bd5a7c3c02" frameborder=0></iframe>

<iframe src="https://medium.com/media/35e918b47c463916b5f74d33080704bd" frameborder=0></iframe>

The main difference with original evalExpr is that we don’t have recursive call to evalExprF (ExpressionF is not recursive, remember?). It also means that our evaluator can work only with a **single level** expression:

<iframe src="https://medium.com/media/592457d79ccf0e2235f9708d6310bfc3" frameborder=0></iframe>

<iframe src="https://medium.com/media/fe7fdb6ca2e8b9b18ff61f9da43a4979" frameborder=0></iframe>

And won’t compile on this:

<iframe src="https://medium.com/media/12008b430d5f131206bf9e568554977d" frameborder=0></iframe>

<iframe src="https://medium.com/media/b36f187bb1521be09b60cbf7db0b68d4" frameborder=0></iframe>

Simply because exprF expepects ExpressionF Int and we’re shoving ExpressionF (ExpressionF Int).

To make it work we could define another evaluator:

<iframe src="https://medium.com/media/5c94d0113a32d67ceaabf807019348ee" frameborder=0></iframe>

<iframe src="https://medium.com/media/1435c9fbea1662e450c77501710c8d94" frameborder=0></iframe>
> Looks kinda ad hoc, what if you have deeply nested expressions?

Yes, for arbitrary nested expression this approach is not scalable — each additional nesting level requires you to write specialized function.

There is a way to generalize this nesting with a new type:

<iframe src="https://medium.com/media/e3571c9ab5458aaa29ed62458b53242c" frameborder=0></iframe>

<iframe src="https://medium.com/media/82decb557d2a707a6aaa529b2653f729" frameborder=0></iframe>
> Fix? Looks like a recursive data structure that doesn’t do much. How is it useful?

Let’s first look at the expression before the equals sign: indeed Fix is a recursive data structure that has one type parameter f. This parameter has kind * -> * e.g. it also takes a type parameter. For example, you can’t construct Fix providing Int or Bool, it has to be something like Maybe, List or… ExpressionF. This is why we introduced type parameter for ExpressionF. Next, after the equals sign we have a single type constructor Fx taking a single argument of type f (Fix f) which is basically an expression that constructs f's value. In case of Maybe it would be Maybe (Fix Maybe) and then the whole thing is wrapped with Fx into type Fix Maybe.

The type signature is confusing to read at first because of type constructor can have the same name as the type itself plus self referencing. But there is not much more to it than just wrapping a higher order type into a data structure. Btw, unfix is an opposite to Fx and all it does is pattern matching on Fx and returns wrapped value, no big deal.

Now, we will replace every ExpressionF of our expression tree with Fix ExpressionF. Notice the difference in constructing expressions with and without Fx — they’re basically the same, except we need to prepend Fx $:

<iframe src="https://medium.com/media/18392f5f223017f06db1ceb5869ff599" frameborder=0></iframe>

<iframe src="https://medium.com/media/04ccf18399dfac46bebc30e4a294084e" frameborder=0></iframe>

The resulting type of a ‘fixed’ version is Fix ExpressionF so we’re back to a recursive representation, but now we have to use unfix function to get our non recursive data structure back.
> What are the benefits of having Fix? Looks like it’s the same approach as original Expression type but now we have this weird Fix and unfix nonsense?

Yes, but we’re trying to generalize the process of folding, it requires introduction of additional abstractions, like Fix and Algebra that we’ll discuss later. Bear with me, it should make more sense later.

So we have our ‘fixed’ data structure, how would evaluation function look like?

<iframe src="https://medium.com/media/b82b29d63692f759af17f7213632d4c5" frameborder=0></iframe>

<iframe src="https://medium.com/media/9655cd366735c6d8ebc7b00c753ad901" frameborder=0></iframe>

Given a Fix ExpressionF the only thing we can do with it is calling unfix which produces ExpressionF (Fix ExpressionF):

<iframe src="https://medium.com/media/57e251d6a09642b1fce769e797e915f2" frameborder=0></iframe>

<iframe src="https://medium.com/media/5e51a7408729de7ed8570099e26e579a" frameborder=0></iframe>

The returned ExpressionF can be one of our ValueF, AddF or MultF having a Fix ExpressionF as their type parameter. It makes sense to do pattern matching and decide what to do next:

<iframe src="https://medium.com/media/cd3ad215af4de0859f1edd3e5c46a98f" frameborder=0></iframe>

<iframe src="https://medium.com/media/3f40079ca6aa10052bdbe00ae98efded" frameborder=0></iframe>

Yes, it looks the same as our very first recursive evaluator for Expression with addition of having to unwrap the expression with unfix. So why bother with Fix anyway?

Here’s the key: we will re-use our original ‘fix-less’ evaluator for ExpressionF and somehow distribute it over the Fix ExpressionF stucture. So this should be a function taking two arguments — the evaluator and the structure to evaluate:

<iframe src="https://medium.com/media/f683b5057783166f420c46dfc30a2b89" frameborder=0></iframe>

<iframe src="https://medium.com/media/e583b9183649988b0df288e25320abff" frameborder=0></iframe>

Let’s try figure out the implementation — the first logical thing to do is to use unfix to get ExpressionF and then maybe pass it to evaluator:

<iframe src="https://medium.com/media/2b97deb3089af12e730af5009b88d5d9" frameborder=0></iframe>

<iframe src="https://medium.com/media/c55b64148dd7e88c75f52d84eb11ae16" frameborder=0></iframe>

Obviously this doesn’t work, evaluator expects ExpressionF Int and not ExpressionF (Fix ExpressionF). By the way, remember that ExpressionF is a Functor? This is where it gets handy — we can use fmap to apply the same process to the inner level of our expression tree:

<iframe src="https://medium.com/media/b743b629fdb5bf7c1240ce6c85d33e76" frameborder=0></iframe>

<iframe src="https://medium.com/media/149a330d8867d5660cfa065a5554e312" frameborder=0></iframe>

Take a moment and think about what happens: we’re passing a recursive function almostCata evaluator into the fmap. If the current expression is AddF or MultF then this function will be passed one level deeper and fmap will be called again. This will happen until we reach ValueF, fmapping over ValueF returns value of type ExpressionF Int and that’s exactly what our evaluator function accepts.

By looking at almostCata we can see that it doesn’t really have anything specific to ExpressionF or Int type and theoretically can be generalized with some type parameter f. The only constraint should be having a Functor instance for f, because we’re using fmap:

<iframe src="https://medium.com/media/f35f78c8b3a9840e4ba01410115b8265" frameborder=0></iframe>

<iframe src="https://medium.com/media/a7aded9189b1df248285f54610ab430a" frameborder=0></iframe>

And that’s the final version of cata. Here’s the full implementation with some usage examples:

<iframe src="https://medium.com/media/a189cc2103bf87b87331cc3b62560685" frameborder=0></iframe>

<iframe src="https://medium.com/media/a8cf77abfb29994f886cf9e601ec27a6" frameborder=0></iframe>
> I guess that’s cool. But why tho?

A lot of concepts in category theory and functional programming are pretty abstract and sometimes it’s hard to find immediate practical application for certain idea. But looking for abstractions and generalizations is useful for finding patterns and elegant solutions to problems that otherwise require ad-hoc implementation.

By the way, by generalizing our ExpressionF -> Int function to Functor f => (f a -> a) we discovered another important concept called **F-Algebra**. Basically F-Algebra is a triple of functor f, some type a and evaluator function f a -> a. Note that a here not polymorphic — it has to be a concrete type, like Int or Bool and it’s called a **carrier type**. For any endo-functor f you can create multiple F-Algebra’s based on it. Take our expressions example — endo-functor f is ExpressionF, a is Int and evaluator is evalExprF. But we can change the carrier type and produce more algebras:

<iframe src="https://medium.com/media/f075686dde7e6c8a495f8f2623c4fdac" frameborder=0></iframe>

<iframe src="https://medium.com/media/aff84229b7dccda1de219c750929cfc8" frameborder=0></iframe>
> That’s just different evaluators that can be passed into cata, right?

Yes, we’re picking different carrier types and choosing our implementation. But there the trick — there is a mother of all evaluators that we can create by picking our carrier type to be… Fix ExprF.

<iframe src="https://medium.com/media/ce7d7e386b3210f56caa0f0d8901bd35" frameborder=0></iframe>

<iframe src="https://medium.com/media/ba04ab6f4d1b33102c7e68e209cdad28" frameborder=0></iframe>
> Evaluating to Int or Bool totally makes sense but what would this initialAlgebra evaluate? When do I need to have Fix of something as a result of my evaluator?

Of course you won’t write something like that yourself, just want to show you the deeper meaning behind f-algebras and cata. In fact, we already have an implementation for such evaluator and thats exactly Fx constructor:

<iframe src="https://medium.com/media/4bf5f398167274e7ffea97aaf8c6a45f" frameborder=0></iframe>

<iframe src="https://medium.com/media/6232d454de685b6f0f085b67ad6a0454" frameborder=0></iframe>
> Wait, Fx is an evaluator? That’s crazy.

Yes and it does the most simple thing you can do — save the expession into a data structure. While all other evaluators (algebra0, algebra1) produced some value by reducing the expression (like doing sum or concatenation) Fx just wraps the expression without loosing any data.

This is why we introduced Fix in the first place — you first evaluate your original data structure with Fx into initial algebra Fix f and then using cata the ‘real’ evaluation happens by fmaping your concrete evaluator over inital algebra.

From category theory point of view, all algebras based on the same endo-functor form a category. This category has an initial object which is our initial algebra created by picking the carrier type as Fix f. There are some great blog posts by Bartosz Milewski that I highly recommend checking out if you want to get deep categorical understanding.
> It’s still pretty hard to comprehend, I don’t think I fully understand the concept

It’s always better to do hands on: try re-implementing Fix and cata on your own, think about possible data structures and algebras. For example, a String can be represented recursively (as a Char head and tail of String), the length of a string can be computed with cata. Here’s some great resources for further reading:

* [Understanding F-Algebras](https://www.schoolofhaskell.com/user/bartosz/understanding-algebras) and slightly different [F-Algebras](https://bartoszmilewski.com/2017/02/28/f-algebras/) by [Bartosz Milewski](https://bartoszmilewski.com)

* [Catamorphisms in 15 minutes](http://chrislambda.github.io/blog/2014/01/30/catamorphisms-in-15-minutes/) by Chris Jones

* [Pure Functional Database Programming with Fixpoint Types](https://www.youtube.com/watch?v=7xSfLPD6tiQ) by Rob Norris

* [Catamorphisms](https://wiki.haskell.org/Catamorphisms) on Haskell wiki

* [Practical recursion schemes](https://jtobin.io/practical-recursion-schemes) by [Jared Tobin](https://jtobin.io)
